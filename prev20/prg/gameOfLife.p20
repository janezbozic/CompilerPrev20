 
#GAME OF LIFE by Jure Viteznik

var sizeX: integer
var sizeY: integer

typ gameboard = boolean[10][10]
var board: ^gameboard

var state: integer

fun main(): void = {
    #board size
    sizeX = 10;
    sizeY = 10;
    state = 0;

    #init board - I hope this is correct
    board = (new(8*100): ^gameboard);
    newBoard = (new(8*100): ^gameboard);
    
    #set all board elements to false
    x = 0;
    while(x < sizeX)do{
        y = 0;
        while(y < sizeY)do{
            board^[x][y] = false;
            newBoard^[x][y] = false;
            y = y+1;
        };
        x = x+1;
    };

    #set some elements to true - uncomment to see different patterns

    #Glider
    #board^[6][3] = true;
    #board^[6][4] = true;
    #board^[6][5] = true;
    #board^[7][5] = true;
    #board^[8][4] = true;

    #Blinker
    #board^[4][3] = true;
    #board^[4][4] = true;
    #board^[4][5] = true;

    #Beacon
    #board^[2][3] = true;
    #board^[2][4] = true;
    #board^[3][3] = true;
    #board^[4][6] = true;
    #board^[5][6] = true;
    #board^[5][5] = true;

    #Toad
    board^[3][3] = true;
    board^[3][4] = true;
    board^[3][5] = true;
    board^[4][4] = true;
    board^[4][5] = true;
    board^[4][6] = true;


    
    print(board);

    #let the game of life begin:D
    while true do{
        putString("Press enter to get to the next state! (type e to exit)");
        putChar((10:char));
        input = getChar();

        if input == 'e' then 
            exit()
        else 1;

        x = 1;
        while(x < sizeX - 1)do{
            y = 1;
            while(y < sizeY - 1)do{
                numOfAlive = aliveNeighbours(x,y, board);
                
                #if alive
                if board^[x][y] then{
                    if(numOfAlive < 2 | numOfAlive > 3) then
                        newBoard^[x][y] = false
                    else 
                        newBoard^[x][y] = true;
                    
                #if dead
                }else{
                    if(numOfAlive == 3) then
                        newBoard^[x][y] = true
                    else 
                        newBoard^[x][y] = false;
                };
                y = y+1;
            }where{
                var numOfAlive: integer
            };
            x = x+1;
        };

        sparePointer = board;
        board = newBoard;
        newBoard = sparePointer;

        state = state + 1;
        putString("state: ");
        putInteger(state);
        putChar((10:char));
        print(board);


    }where{
        var sparePointer: ^gameboard

        #returns a number of live neighbours - lets put it here since we can :)
        fun aliveNeighbours(x:integer, y:integer, board: ^gameboard): integer = {
            numOfNeigh = 0;
            xiter = x-1;
            while(xiter <= x+1) do{
                yiter = y-1;
                while(yiter <= y+1) do{
                    if board^[xiter][yiter] then 
                        numOfNeigh = numOfNeigh+1
                    else 1; #just a stmt
                    yiter = yiter+1;
                };
                xiter = xiter+1;
            };

            #x,y is not a neighbour
            if board^[x][y] then
                numOfNeigh = numOfNeigh - 1
            else 1;

            #return
            numOfNeigh;
        }where{
            var xiter: integer
            var yiter: integer
            var numOfNeigh: integer
        }

    };
}where{
    var x: integer
    var y: integer
    var newBoard: ^gameboard
    var input: char

    fun print(board: ^gameboard): void = {
            x = 1;
            while(x < sizeX - 1)do{
                y = 1;
                while(y < sizeY - 1)do{
                    if board^[x][y] then
                        putChar('O')
                    else
                        putChar(' ');

                    y = y+1;
                };

                putChar((10:char));
                x = x+1;
            };
            putString("----------------");
            putChar((10:char));
        }
}


###########################
# functions from profesor #
###########################
fun exit():void = none
fun putChar(c:char):void = none
fun getChar():char = (0:char)

fun putInteger(i:integer):void =
    {
      if (i<0) then { putChar('-'); i=-i; } else none;
      if (i==0) then putChar('0') else put(i);
    }
    where
    {
      fun put(i:integer):void =
          {
            if (i==0) then none else {
              put(i/10);
              putChar(((i%10+('0':integer)):char));
            };
          }
    }

fun getInteger():integer =
    {
      sign=1;
      val=0;
      c = getChar();
      if (c=='+') then { sign=+1; c='0'; } else
      if (c=='-') then { sign=-1; c='0'; } else
      if (c<'0')|(c>'9') then exit() else none;
      while ('0'<=c)&(c<='9') do {
        val=val*10+((c:integer)-('0':integer));
        c=getChar();
      };
      if (c!=(10:char)) then exit() else none;
      sign * val;
    }
    where
    {
      var sign:integer
      var val:integer
      var c:char
    }

fun putString(s:^char):void =
    {
      i=0;
      while (((s:integer)+(i*8):^char)^!=(0:char)) do {
        putChar(((s:integer)+(i*8):^char)^);
        i=i+1;
      };
      none;
    }
    where
    {
      var i:integer
    }
